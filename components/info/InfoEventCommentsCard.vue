<template>
  <div v-if="comment" class="ml-4 mt-2 mb-4 border-l-2 border-bgSecondary-light dark:border-bgSecondary-dark">
    <div class="overflow-auto overflow-wrap break-words">
      <div class="text-colorNotImportant-light dark:text-colorNotImportant-dark">
        <span v-if="comment.authors?.[0].addresses?.[0].value?.toString()">
          <span v-if="showActionDetails">Author: </span>
          <ExtraBlockies :seed="comment.authors?.[0].addresses?.[0].value?.toString()" :scale="2" class="inline-block mr-1" />
          <nuxt-link :to="`/authors/${comment.authors?.[0].addresses?.[0].value?.toString()}`"
            class="text-colorPrimary-light dark:text-colorPrimary-dark hover:underline">

          <!-- client-only tags solve hydration mismatch warning -->
          <client-only>
            <span
              v-if="getMetadataByAddressNostr(comment.authors?.[0].addresses?.[0].value?.toString(), 'username') && getMetadataByAddressNostr(comment.authors?.[0].addresses?.[0].value?.toString(), 'username') !== 'none'"
              class="ml-1"
            >
              <span class="">
                {{ getMetadataByAddressNostr(comment.authors?.[0].addresses?.[0].value?.toString(), 'username').slice(0,40) }}
              </span>
              <span class="text-sm">
                (Nostr)
              </span>
            </span>

            <span v-else class="ml-1" >
              <span v-if="enableAutoGeneratedNames">
                {{autoGeneratedName(comment.authors?.[0].addresses?.[0].value?.toString())}}
                ({{sliceAddress(comment.authors?.[0].addresses?.[0].value?.toString(), 6)}})
              </span>
              <span v-else>
                {{sliceAddress(comment.authors?.[0].addresses?.[0].value?.toString(), 6)}}
              </span>
            </span>
          </client-only>

          </nuxt-link>
          <ExtraAddressIcons
            v-if="comment.authors?.[0].addresses?.[0].value?.toString()"
            :key="comment.authors?.[0].addresses?.[0].value?.toString()"
            :value="comment.authors?.[0].addresses?.[0].value?.toString()"
            :showCopyToClipboard="true"
            :showQrCode="true"
            :showExternalWebsite="true"
          />
        </span>
        <span v-if="showActionDetails">
          <span class="ml-1">
            <span class="signatureLabel">Signature: </span>
            <nuxt-link class="text-colorPrimary-light dark:text-colorPrimary-dark hover:underline"
              :to="`/news/${String(comment.signatures?.[0].value)}`">
            {{sliceAddress(String(comment.signatures?.[0].value))}}
            </nuxt-link>
            <ExtraAddressIcons
              v-if="String(comment.signatures?.[0].value)"
              :key="String(comment.signatures?.[0].value)"
              :value="String(comment.signatures?.[0].value)"
              :showCopyToClipboard="true"
            />
          </span>
          <span v-if="String(comment.parent?.ids?.[0].value)">
            <span class="ml-1">Target: </span>
            <nuxt-link class="text-colorPrimary-light dark:text-colorPrimary-dark hover:underline"
              :to="`/news/?p=${String(comment.parent?.ids?.[0].value)}`">
              <span>
                {{sliceAddress(String(comment.parent?.ids?.[0].value))}}
              </span>
            </nuxt-link>
            <ExtraAddressIcons
              v-if="String(comment.parent?.ids?.[0].value)"
              :key="String(comment.parent?.ids?.[0].value)"
              :value="String(comment.parent?.ids?.[0].value)"
              :showCopyToClipboard="true"
            />
          </span>
        </span>
        <!-- short URL -->
        <nuxt-link v-if="String(comment.signatures?.[0].value) && enableShortUrlsForWeb3Actions" :to="`/news/${String(comment.signatures?.[0].value).slice(0,shortUrlsLengthOfWeb3Ids)}`" class="nuxt-link text-colorNotImportant-light dark:text-colorNotImportant-dark hover:text-colorPrimary-light dark:hover:text-colorPrimary-dark">
          <span v-if="comment.timestamp">
            ({{toBeDate(comment.timestamp)}})
          </span>
        </nuxt-link>
        <!-- full URL -->
        <nuxt-link v-if="String(comment.signatures?.[0].value) && !enableShortUrlsForWeb3Actions" :to="`/news/${String(comment.signatures?.[0].value)}`" class="nuxt-link text-colorNotImportant-light dark:text-colorNotImportant-dark hover:text-colorPrimary-light dark:hover:text-colorPrimary-dark">
          <span v-if="comment.timestamp">
            ({{toBeDate(comment.timestamp)}})
          </span>
        </nuxt-link>
      </div>

      <div>
        <h6 v-if="comment.title" class="font-bold">
          {{comment.title}}
        </h6>
      </div>

      <div v-if="comment.content" class="whitespace-pre-line my-1 pl-1">

        <!-- No iframe tags -->
        <div v-if="!isSignerAllowedIframe">
          <!-- Plain text -->
          <div v-if="!enableMarkdownInComments">
            {{comment.content}}
          </div>
          <!-- Markdown if enabled -->
          <div
            v-if="enableMarkdownInComments"
            v-dompurify-html="(marked(comment.content, {breaks:true}))"
          />
        </div>

        <!-- Iframe tags -->
        <div v-if="isSignerAllowedIframe">
          <div
            v-for="(textChunk, index) in arrayOfTextChunks"
            :key="randomNumber()"
          >
            <!-- Markdown if enabled -->
            <div
              v-if="enableMarkdownInComments && textChunk"
              v-dompurify-html="(marked(textChunk, {breaks:true}))"
            />
            <!-- Plain text if markdown is disabled -->
            <div v-if="!enableMarkdownInComments && textChunk">
              {{textChunk}}
            </div>
            <!-- HTML tags (e.g. iframe) -->
            <!--
              DOMPurify is not used so tags can be embedded.
              HTML tags in arrayOfHtmlTags are generated by the
              script and only for whitelisted users.
            -->
            <div
              v-if="arrayOfHtmlTags && arrayOfHtmlTags[index]"
              v-html="arrayOfHtmlTags[index]"
            />
          </div>
        </div>

      </div>

    </div>

    <div>
      <InfoEventCommentsCardReactionsBar :comment="comment" class="mr-1"/>

      <span v-if="showCommentsCount">
        <nuxt-link :to="`/news/?p=${String(comment.signatures?.[0].value)}`">
          <button v-if="spasm.getTotalOfReply(comment)" class="inline-block mr-2 text-colorBlue-light dark:text-colorBlue-dark">
            <span
              v-if="spasm.getTotalOfReply(comment)"
              class="mr-2 text-colorBlue-light dark:text-colorBlue-dark">
              <IconsComments class="custom-icons" />
              {{spasm.getTotalOfReply(comment)}}
            </span>
          </button>
        </nuxt-link>
      </span>

      <div v-if="enableNewWeb3ActionsAll && enableNewWeb3ActionsReply" class="inline-block">
        <div class="inline-block text-lg lg:text-base text-colorNotImportant-light dark:text-colorNotImportant-dark cursor-pointer hover:text-colorPrimary-light dark:hover:text-colorPrimary-dark" @click="toggleReplyForm">
          {{showReplyFormText}}
        </div>
      </div>

      <InfoPostCommentInputField v-if="showReplyForm" :target="String(comment.signatures?.[0].value)" @reply-submitted="replySubmitted" />
    </div>

    <!--
      Actions like replies and reactions can come from child
      comments, so we have to emit them up to InfoPostComments.
    -->
    <div v-if="comment.children" class="children">
      <InfoEventCommentsCard
        v-for="child in comment.children"
        :id="child.ids?.[0].value"
        :key="child.ids?.[0].value"
        :comment="child.event"
        :show-action-details="showActionDetails"
        :show-comments-count="showCommentsCount"
        @reply-submitted="replySubmitted"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import {marked} from 'marked'
import {
  /* SpasmEventChildV2, */
  SpasmEventV2
} from '@/helpers/interfaces'
import { spasm } from 'spasm.js'

// Nostr usernames
import { storeToRefs } from 'pinia'
import {useProfilesStore} from '@/stores/useProfilesStore'
const profilesStore = useProfilesStore()
const { getMetadataByAddressNostr } = storeToRefs(profilesStore)

const {sliceAddress, randomNumber} = useWeb3()
const {
  autoGeneratedName, toBeDate
} = useUtils()
const env = useRuntimeConfig()?.public
const enableAutoGeneratedNames: boolean = env?.enableAutoGeneratedNames === 'false'? false : true
const enableMarkdownInComments = env?.enableMarkdownInComments === 'true'? true : false
const enableEmbedIframeTagsInComments = env?.enableEmbedIframeTagsInComments === 'true'? true : false
// New web3 actions are enabled by default if not disabled in .env
const enableNewWeb3ActionsAll: boolean = env?.enableNewWeb3ActionsAll === 'false'? false : true
const enableNewWeb3ActionsReply: boolean = env?.enableNewWeb3ActionsReply === 'false'? false : true
// Short URLs for web3 actions are enabled by default if not disabled in .env
const enableShortUrlsForWeb3Actions: boolean = env?.enableShortUrlsForWeb3Actions === 'false'? false : true
const shortUrlsLengthOfWeb3Ids: number = env?.shortUrlsLengthOfWeb3Ids ? Number(env?.shortUrlsLengthOfWeb3Ids) : 20
const {checkIfSignerAllowedIframe, getArrayOfArraysOfTextAndTagsV2} = useHtmlTags()

const props = defineProps<{
  /* comment?: SpasmEventChildV2 */
  comment?: SpasmEventV2
  key?: (string | number)
  showActionDetails?: boolean
  showCommentsCount?: boolean
}>()

const emit = defineEmits<{
  (e: 'reply-submitted', target?: string | number | null): void
}>()

const replySubmitted = (target?: string | number | null) => {
  /* console.log('reply was submitted for target:', target) */
  showReplyForm.value = false
  showReplyFormText.value = 'reply'
  emit('reply-submitted', target)
}

const showReplyForm = ref(false)
const showReplyFormText = ref('reply')

const toggleReplyForm = () => {
      showReplyForm.value = !showReplyForm.value
      showReplyFormText.value = showReplyFormText.value === 'reply'
        ? 'hide'
        : 'reply'
    }

// Iframe tags
let isSignerAllowedIframe: boolean = false
let arrayOfTextChunks: string[] = ['']
let arrayOfHtmlTags: string[] = ['']

if (enableEmbedIframeTagsInComments) {
  // Check if a signer is allowed to embed iframe tags
  if (typeof(props?.comment?.authors?.[0].addresses?.[0].value?.toString()) === 'string') {
    isSignerAllowedIframe = checkIfSignerAllowedIframe(props?.comment?.authors?.[0].addresses?.[0].value?.toString())
  }

  // Add iframe tags if text has any iframe URLs
  // WARNING: it's very important to check whether the
  // signer is allowed to add iframe tags because that's
  // a potential attack vector.
  if (typeof(props?.comment?.content) === 'string' && isSignerAllowedIframe) {
    const arrayOfArraysOfTextAndTags: string[][] | null =
      getArrayOfArraysOfTextAndTagsV2(props?.comment)
    if (arrayOfArraysOfTextAndTags) {
      arrayOfTextChunks = arrayOfArraysOfTextAndTags[0]
      arrayOfHtmlTags = arrayOfArraysOfTextAndTags[1]
    }
  }
}

// Add addresses to a list of addresses that should be checked
// for profile info (e.g. usernames) during an update function.
if (process.client) {
  if (
    props?.comment && props?.comment &&
    props?.comment?.authors?.[0].addresses?.[0].value
  ) {
    const signer: string | null = String(
      props?.comment?.authors?.[0].addresses?.[0].value
    )
    if (signer) {
      profilesStore.addAddress(signer)
    }
  }
}
</script>

<style scoped>

</style>
