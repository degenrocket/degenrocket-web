<template>
  <div class="p-1 py-2 border-b border-borderColor-light dark:border-borderColor-dark"
    :class="[isSelectedPost ? 'bg-bgHover-light dark:bg-bgHover-dark' : '']">
    <!-- show title with nuxt-link to id if post has no signature (web2) -->
    <div class="">
      <span v-if="post.db?.addedTimestamp"
        class="mr-1 text-colorNotImportant-light dark:text-colorNotImportant-dark">
        {{timeAgoEvent}}
      </span>
      <span v-if="post.source?.name" class="text-colorNotImportant-light dark:text-colorNotImportant-dark">
        {{post.source?.name}}
      </span>
      <span
        v-if="post.authors?.[0].addresses?.[0].value && post.authors?.[0].addresses?.[0].verified"
        class=""
      >
        <nuxt-link
          :to="`/authors/${post.authors?.[0].addresses?.[0].value}`"
          @click="hideFeed()"
          class="nuxt-link text-colorNotImportant-light dark:text-colorNotImportant-dark"
        >
          <ExtraBlockies :seed="addressValue" :scale="2" class="inline-block" />
          <!-- client-only tags solve hydration mismatch warning -->
          <client-only>
            <span
              v-if="getMetadataByAddressNostr(addressValue, 'username') && getMetadataByAddressNostr(addressValue, 'username') !== 'none'"
              class="ml-1"
            >
              <span class="">
                {{ getMetadataByAddressNostr(addressValue, 'username').slice(0,40) }}
              </span>
              <span class="text-sm">
                (Nostr)
              </span>
            </span>

          <span v-else class="ml-1" >
            <span>
              {{ addressForDisplay }}
            </span>
          </span>
          </client-only>
        </nuxt-link>
      </span>
    </div>
    <!-- clr restores the next line to default behaviour after float:right -->
    <div class="clr" />

    <div v-if="extractIdForDisplay(post)">
      <nuxt-link
        :to="`/news/${extractIdForDisplay(post)}`"
        class="nuxt-link"
      >
        <span
          v-if="post.title"
          @click="postClicked()"
        >{{post.title.slice(0, 100)}}</span>
        <span
          v-if="!post.title && post.content"
          @click="postClicked()"
        >{{post.content.slice(0, 100)}}</span>
      </nuxt-link>
    </div>

    <div>
      <span v-if="spasm.getTotalOfReaction(post, 'bullish')" class="mr-2 text-colorGreen-light dark:text-colorGreen-dark">
        <IconsBullish class="custom-icons" />
        {{spasm.getTotalOfReaction(post, 'bullish')}}
      </span>
      <span v-if="spasm.getTotalOfReaction(post, 'bearish')" class="mr-2 text-colorRed-light dark:text-colorRed-dark">
        <IconsBearish class="custom-icons" />
        {{spasm.getTotalOfReaction(post, 'bearish')}}
      </span>
      <span v-if="spasm.getTotalOfReaction(post, 'important')" class="mr-2 text-colorOrange-light dark:text-colorOrange-dark">
        <IconsImportant class="custom-icons" />
        {{spasm.getTotalOfReaction(post, 'important')}}
      </span>
      <span v-if="spasm.getTotalOfReaction(post, 'scam')" class="mr-2 text-colorRed-light dark:text-colorRed-dark">
        <IconsScam class="custom-icons" />
        {{spasm.getTotalOfReaction(post, 'scam')}}
      </span>
      <span v-if="spasm.getTotalOfReaction(post, 'upvote')" class="mr-2 text-colorNotImportant-light dark:text-colorNotImportant-dark">
        <IconsUpvote class="custom-icons" />
        {{spasm.getTotalOfReaction(post, 'upvote')}}
      </span>
      <span v-if="spasm.getTotalOfReaction(post, 'downvote')" class="mr-2 text-colorNotImportant-light dark:text-colorNotImportant-dark">
        <IconsDownvote class="custom-icons" />
        {{spasm.getTotalOfReaction(post, 'downvote')}}
      </span>
      <span v-if="spasm.getTotalOfReply(post)" class="mr-2 text-colorBlue-light dark:text-colorBlue-dark">
        <IconsComments class="custom-icons" />
        {{spasm.getTotalOfReply(post)}}
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
import {
  SpasmEventV2
} from '@/helpers/interfaces';
import { spasm } from 'spasm.js'

// Nostr usernames
import { storeToRefs } from 'pinia'
import {useProfilesStore} from '@/stores/useProfilesStore'
const profilesStore = useProfilesStore()
const { getMetadataByAddressNostr } = storeToRefs(profilesStore)

const {
  extractIdForDisplay,
  extractOneAuthorAddressForDisplay
} = useWeb3()
/* const {autoGeneratedName} = useUtils() */
const {id} = useRoute().params
const isSelectedPost = ref<boolean>(false)
const {hideFeed} = useFeed()

const props = defineProps<{
  post: SpasmEventV2
  key?: (string | number)
}>()

const addressForDisplay = extractOneAuthorAddressForDisplay(props?.post)
const addressValue = extractOneAuthorAddressForDisplay(props?.post, true)

/* console.log(`FeedPostsCard called */
/* props.key: ${props.key}           */
/* props.post: ${props.post}`)       */
/* console.log(props.post)           */

// Highlight the post card in the feed section
// if the post is displayed in the info section.
const checkIfSelected = (
  id: (string | number) | (string | number)[] | undefined
): boolean => {
  if (Array.isArray(id)) {return false}

  if (id) {
    return props.post.ids?.[0].value.toString() === id ||
      props.post.signatures?.[0].value === id
  } else {
    return false
  }
}

isSelectedPost.value = checkIfSelected(id)

watch(() => useRoute().params.id, newId => {
  isSelectedPost.value = checkIfSelected(newId)
})

let timeAgoEvent = ref(useTime().timeAgoEvent(props.post))
let timeAgoUpdateInterval: ReturnType<typeof setInterval>

onMounted(() => {
  // Warning: potential memory leak!
  // Make sure to clearInterval when onUnmounted()
  const updateTimeAgo = () => {
    timeAgoEvent.value = useTime().timeAgoEvent(props.post)
  }

  // update every 60 seconds
  timeAgoUpdateInterval = setInterval(updateTimeAgo, 60000)
})

onUnmounted(() => {
  clearInterval(timeAgoUpdateInterval)
  /* timeAgoUpdateInterval = null */
})

const postClicked = () => {
  hideFeed()
}

// Add a signer address to a list of addresses that should be
// updated once everything else is loaded.
// The update will fetch profiles associated with these addresses.
if (process.client) {
  if (
    props?.post.authors?.[0].addresses?.[0].value
  ) {
    profilesStore.addAddress(
      props.post.authors?.[0].addresses?.[0].value.toString()
    )
  }
}

</script>

<style scoped>

</style>
